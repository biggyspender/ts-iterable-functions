import { deferP0 } from "ts-functional-pipe";
import { toIterable } from "../helpers/toIterable";
import { GroupedIterable } from "../types/GroupedIterable";
import { IndexedSelector } from "../types/IndexedSelector";
import { MapFactory } from "../types/MapFactory";
import { _toLookup } from "./toLookup";

function createGroupedIterable<K, V>(
  key: K,
  value: Iterable<V>,
): GroupedIterable<K, V> {
  return {
    [Symbol.iterator]: function* () {
      for (const x of value) {
        yield x;
      }
    },
    key,
    toJSON(): V[] {
      return [...value];
    },
  };
}

/**
 * Groups elements from the source iterable by key and returns lazy grouped iterables for each bucket.
 *
 * @typeParam T - Element type produced by the source iterable.
 * @typeParam TKey - Key type generated by the key selector.
 * @param src - Source iterable enumerated to populate the lookup.
 * @param keySelector - Selector invoked with each element and index to produce a key.
 * @param mapFactory - Optional factory used to construct the internal map for lookups.
 * @returns A deferred iterable emitting grouped iterables keyed by the selector output.
 *
 * @example
 * ```ts
 * const groups = [..._groupBy(
 *   ["ant", "bat", "apple"],
 *   (word) => word[0]
 * )].map((group) => ({ key: group.key, values: [...group] }));
 * console.log(groups);
 * // [
 * //   { key: "a", values: ["ant", "apple"] },
 * //   { key: "b", values: ["bat"] }
 * // ]
 * ```
 *
 * or using the curried version:
 * ```ts
 * const groups = pipeInto(
 *   [
 *     { category: "fruit", item: "apple" },
 *     { category: "fruit", item: "banana" },
 *     { category: "veg", item: "carrot" }
 *   ],
 *   groupBy((entry) => entry.category)
 * );
 * const shaped = [...groups].map((group) => ({
 *   key: group.key,
 *   items: [...group].map((entry) => entry.item)
 * }));
 * console.log(shaped);
 * // [
 * //   { key: "fruit", items: ["apple", "banana"] },
 * //   { key: "veg", items: ["carrot"] }
 * // ]
 * ```
 */
export function _groupBy<T, TKey>(
  src: Iterable<T>,
  keySelector: IndexedSelector<T, TKey>,
  mapFactory?: MapFactory<TKey>,
): Iterable<GroupedIterable<TKey, T>> {
  return toIterable(function* () {
    const lookup = _toLookup(src, keySelector, mapFactory);
    for (const [key, value] of lookup) {
      yield createGroupedIterable(key, value);
    }
  });
}

/**
 * Curried version of {@link _groupBy}.
 */
export const groupBy = deferP0(_groupBy);
