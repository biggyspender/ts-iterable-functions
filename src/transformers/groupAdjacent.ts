import { deferP0 } from "ts-functional-pipe";
import { toIterable } from "../helpers/toIterable";
import { IndexedSelector } from "../types/IndexedSelector";

/**
 * Groups adjacent elements that share an equal key and projects each group into a result.
 *
 * @typeParam TSource - Element type produced by the source iterable.
 * @typeParam TKey - Key type generated by the key selector.
 * @typeParam TElement - Element type produced by the element selector for each group.
 * @typeParam TResult - Result type emitted by the group projection.
 * @param src - Source iterable enumerated sequentially for grouping.
 * @param keySelector - Selector producing a key for each source element.
 * @param elementSelector - Selector producing the element stored for each group member.
 * @param resultSelector - Projection invoked with the key and grouped elements.
 * @param equalityComparer - Optional key comparer; defaults to strict equality when omitted.
 * @returns A deferred iterable emitting one projected result for each run of equal keys.
 *
 * @example
 * ```ts
 * const result = [..._groupAdjacent(
 *   [1, 1, 2, 3, 3],
 *   (value) => value,
 *   (value) => value * 2,
 *   (key, items) => ({ key, doubled: [...items] })
 * )];
 * console.log(result);
 * // [
 * //   { key: 1, doubled: [2, 2] },
 * //   { key: 2, doubled: [4] },
 * //   { key: 3, doubled: [6, 6] }
 * // ]
 * ```
 *
 * or using the curried version:
 * ```ts
 * const result = pipeInto(
 *   ["a", "a", "b"],
 *   groupAdjacent(
 *     (value) => value,
 *     (value) => value.toUpperCase(),
 *     (key, items) => ({ key, items: [...items] })
 *   )
 * );
 * console.log([...result]);
 * // [
 * //   { key: "a", items: ["A", "A"] },
 * //   { key: "b", items: ["B"] }
 * // ]
 * ```
 */
export function _groupAdjacent<TSource, TKey, TElement, TResult>(
  src: Iterable<TSource>,
  keySelector: IndexedSelector<TSource, TKey>,
  elementSelector: IndexedSelector<TSource, TElement>,
  resultSelector: (key: TKey, items: Iterable<TElement>) => TResult,
  equalityComparer?: (a: TKey | undefined, b: TKey | undefined) => boolean,
): Iterable<TResult> {
  const source = src;
  const eq = equalityComparer
    ? (a: TKey | undefined, b: TKey | undefined) =>
        typeof a !== "undefined" &&
        typeof b !== "undefined" &&
        equalityComparer(a, b)
    : (a: TKey | undefined, b: TKey | undefined) =>
        typeof a !== "undefined" && typeof b !== "undefined" && a === b;
  return toIterable(
    /* istanbul ignore next */ function* () {
      const iterator = source[Symbol.iterator]();

      let group: TKey | undefined = undefined;
      let members: TElement[] | undefined = undefined;

      let i = 0;
      let itResult;
      while (!(itResult = iterator.next()).done) {
        const idx = i++;
        const key = keySelector(itResult.value, idx);
        const element = elementSelector(itResult.value, idx);
        if (typeof members !== "undefined" && eq(group, key)) {
          members.push(element);
        } else {
          if (typeof members !== "undefined" && typeof group !== "undefined") {
            yield resultSelector(group, members);
          }
          group = key;
          members = [element];
        }
      }
      if (typeof members !== "undefined" && typeof group !== "undefined") {
        yield resultSelector(group, members);
      }
    },
  );
}

/**
 * Curried version of {@link _groupAdjacent}.
 */
export const groupAdjacent = deferP0(_groupAdjacent);
