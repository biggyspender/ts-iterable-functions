import { deferP0, pipeInto as pp } from "ts-functional-pipe";
import { toIterable } from "../helpers/toIterable";
import { IndexedSelector } from "../types/IndexedSelector";
import { MapFactory } from "../types/MapFactory";
import { concat } from "./concat";
import { distinct } from "./distinct";
import { map, _map } from "./map";
import { _toLookup } from "./toLookup";

/**
 * Performs a full outer join that supplies grouped left and right sequences for each distinct key.
 *
 * @typeParam T - Element type produced by the left source iterable.
 * @typeParam TRight - Element type produced by the right source iterable.
 * @typeParam TKey - Key type generated by the key selector functions.
 * @typeParam TOut - Result type emitted by the `selector`.
 * @param src - Left source iterable evaluated to build the left-side lookup.
 * @param rightSeq - Right source iterable evaluated alongside the left lookup.
 * @param leftKeySelector - Selector producing a key for each left element.
 * @param rightKeySelector - Selector producing a key for each right element.
 * @param selector - Projection that receives the grouped left items, grouped right items, and their key.
 * @param mapFactory - Optional factory used to create the internal map for grouping.
 * @returns A deferred iterable yielding one result per distinct key across both sequences.
 *
 * @example
 * ```ts
 * const result = [..._fullOuterGroupJoin(
 *   [
 *     { id: 1, label: "L1" },
 *     { id: 2, label: "L2" }
 *   ],
 *   [
 *     { id: 2, label: "R2" },
 *     { id: 3, label: "R3" }
 *   ],
 *   (left) => left.id,
 *   (right) => right.id,
 *   (leftItems, rightItems, id) => ({
 *     id,
 *     left: [...leftItems].map((x) => x.label),
 *     right: [...rightItems].map((x) => x.label)
 *   })
 * )];
 * console.log(result);
 * // [
 * //   { id: 1, left: ["L1"], right: [] },
 * //   { id: 2, left: ["L2"], right: ["R2"] },
 * //   { id: 3, left: [], right: ["R3"] }
 * // ]
 * ```
 *
 * or using the curried version:
 * ```ts
 * const result = pipeInto(
 *   [
 *     { id: 1, label: "A" }
 *   ],
 *   fullOuterGroupJoin(
 *     [
 *       { id: 1, label: "B" },
 *       { id: 2, label: "C" }
 *     ],
 *     (left) => left.id,
 *     (right) => right.id,
 *     (leftItems, rightItems, id) => ({
 *       id,
 *       left: [...leftItems].map((item) => item.label),
 *       right: [...rightItems].map((item) => item.label)
 *     })
 *   )
 * );
 * console.log([...result]);
 * // [
 * //   { id: 1, left: ["A"], right: ["B"] },
 * //   { id: 2, left: [], right: ["C"] }
 * // ]
 * ```
 */
export function _fullOuterGroupJoin<T, TRight, TKey, TOut>(
  src: Iterable<T>,
  rightSeq: Iterable<TRight>,
  leftKeySelector: IndexedSelector<T, TKey>,
  rightKeySelector: IndexedSelector<TRight, TKey>,
  selector: (o: Iterable<T>, v: Iterable<TRight>, k: TKey) => TOut,
  mapFactory?: MapFactory<TKey>
): Iterable<TOut> {
  return toIterable(function* () {
    const right = rightSeq;
    const leftLookup = _toLookup(src, leftKeySelector, mapFactory);
    const rightLookup = _toLookup(right, rightKeySelector, mapFactory);
    const rightLookupKeys = _map(rightLookup, ([key, _]) => key);
    const allKeys = pp(
      leftLookup,
      map(([key, _]) => key),
      concat(rightLookupKeys),
      distinct()
    );

    const outputValues = pp(
      allKeys,
      map((key) => ({ key, leftItem: leftLookup.get(key) ?? [] })),
      map(({ key, leftItem }) => ({
        key,
        leftItem,
        rightItem: rightLookup.get(key) ?? [],
      })),
      map((x) => selector(x.leftItem, x.rightItem, x.key))
    );
    for (const v of outputValues) {
      yield v;
    }
  });
}

/**
 * Curried version of {@link _fullOuterGroupJoin}.
 */
export const fullOuterGroupJoin = deferP0(_fullOuterGroupJoin);
