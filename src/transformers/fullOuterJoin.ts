import { deferP0, pipeInto as pp } from "ts-functional-pipe";
import { IndexedSelector } from "../types/IndexedSelector";
import { MapFactory } from "../types/MapFactory";
import { defaultIfEmpty } from "./defaultIfEmpty";
import { flatMap } from "./flatMap";
import { fullOuterGroupJoin } from "./fullOuterGroupJoin";
import getIdentity from "./helpers/getIdentity";
import { map } from "./map";

const identity = getIdentity();

/**
 * Performs a full outer join by pairing elements from both iterables for every distinct key.
 *
 * @typeParam T - Element type produced by the left source iterable.
 * @typeParam TRight - Element type produced by the right source iterable.
 * @typeParam TKey - Key type generated by the key selector functions.
 * @typeParam TOut - Result type emitted by the `selector`.
 * @param src - Left source iterable evaluated for outer join matches.
 * @param rightSeq - Right source iterable evaluated for outer join matches.
 * @param leftKeySelector - Selector producing a key for each left element.
 * @param rightKeySelector - Selector producing a key for each right element.
 * @param selector - Projection receiving optional left and right elements plus the shared key.
 * @param mapFactory - Optional factory used to create the internal map for key lookups.
 * @returns A deferred iterable yielding the result of `selector` for each matched key combination.
 *
 * @example
 * ```ts
 * const result = [..._fullOuterJoin(
 *   [
 *     { id: 1, label: "L1" },
 *     { id: 2, label: "L2" }
 *   ],
 *   [
 *     { id: 2, label: "R2" },
 *     { id: 3, label: "R3" }
 *   ],
 *   (left) => left.id,
 *   (right) => right.id,
 *   (left, right, id) => ({
 *     id,
 *     left: left?.label,
 *     right: right?.label
 *   })
 * )];
 * console.log(result);
 * // [
 * //   { id: 1, left: "L1", right: undefined },
 * //   { id: 2, left: "L2", right: "R2" },
 * //   { id: 3, left: undefined, right: "R3" }
 * // ]
 * ```
 *
 * or using the curried version:
 * ```ts
 * const result = pipeInto(
 *   [
 *     { id: 1, name: "Alice" }
 *   ],
 *   fullOuterJoin(
 *     [
 *       { id: 1, city: "Paris" },
 *       { id: 2, city: "Rome" }
 *     ],
 *     (left) => left.id,
 *     (right) => right.id,
 *     (left, right, id) => ({
 *       id,
 *       name: left?.name ?? null,
 *       city: right?.city ?? null
 *     })
 *   )
 * );
 * console.log([...result]);
 * // [
 * //   { id: 1, name: "Alice", city: "Paris" },
 * //   { id: 2, name: null, city: "Rome" }
 * // ]
 * ```
 */
export function _fullOuterJoin<T, TRight, TKey, TOut>(
  src: Iterable<T>,
  rightSeq: Iterable<TRight>,
  leftKeySelector: IndexedSelector<T, TKey>,
  rightKeySelector: IndexedSelector<TRight, TKey>,
  selector: (o: T | undefined, v: TRight | undefined, k: TKey) => TOut,
  mapFactory?: MapFactory<TKey>,
): Iterable<TOut> {
  return pp(
    src,
    fullOuterGroupJoin(
      rightSeq,
      leftKeySelector,
      rightKeySelector,
      (lft, rgt, i) =>
        pp(
          lft,
          defaultIfEmpty(),
          flatMap((l) =>
            pp(
              rgt,
              defaultIfEmpty(),
              map((r) => selector(l, r, i)),
            ),
          ),
        ),
      mapFactory,
    ),
    flatMap(identity),
  );
}

/**
 * Curried version of {@link _fullOuterJoin}.
 */
export const fullOuterJoin = deferP0(_fullOuterJoin);
